<!DOCTYPE html>
<html>


<link rel="stylesheet" href="/scss/main.css" />


<script src="/js/batch-load.js"></script>
<noscript>
    <style>
        .image-container {
            opacity: 1 !important;
        }
    </style>
</noscript>

<meta name="viewport" content="width=device-width, initial-scale=1">



<head>
 <title>Kalin Kochnev</title>
 <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
</head>
<body>
        <div id="content"><header>
  <nav class="navbar" role="navigation">
    <div id="face-icon">

      <a href="/">
        




    
        
    
    <img
    src="/images/face_hu13438898370780653792.webp"
    
    
    
    loading="lazy" 

    style="
         
        
        
    "
    />



      </a>
      <div id="name">
        
        <a href="/">kalin kochnev</a>
        
      </div>
    </div>

    <div id="right">
      <a href="/journey">journeys</a>
      <a href="/blog">blog</a>
      <a href="https://docs.google.com/document/d/1FXmMWEolckjuU6kRzWDw5hp8Wdx4OKgeXBfyINB-kUM/edit?usp=sharing">resume</a>
    </div>
  </nav>
</header>

<div class="single-container">
    <div class="post-page">
        <a href="https://kalinkochnev.com/journey/graphics/" id="nav-parent" class="link-style"> <span 
     
>
    <svg width="18.167" height="30" xmlns="http://www.w3.org/2000/svg"><g color="#000"><path d="M46.411 51.77a4.868 4.868 0 0 0 0 6.9L67.11 79.369c1.911 1.91 4.988 1.91 6.9 0s1.91-4.989 0-6.9L56.76 55.22l17.25-17.249c1.91-1.911 1.91-4.988 0-6.9s-4.989-1.91-6.9 0z" style="-inkscape-stroke:none" transform="translate(-25.339 -16.569) scale(.5717)"/><path d="M70.561 28.982c-1.418 0-2.837.54-3.918 1.621l-20.699 20.7a5.541 5.541 0 0 0 0 7.833l20.699 20.7a5.541 5.541 0 0 0 7.834 0 5.541 5.541 0 0 0 0-7.835l-16.781-16.78 16.781-16.782a5.544 5.544 0 0 0 0-7.836 5.519 5.519 0 0 0-3.916-1.62zm0 1.313c1.076 0 2.152.414 2.982 1.244a4.194 4.194 0 0 1 0 5.964L55.826 55.22l17.717 17.717a4.192 4.192 0 0 1 0 5.963 4.194 4.194 0 0 1-5.964 0l-20.7-20.697a4.194 4.194 0 0 1 0-5.965l20.7-20.698a4.204 4.204 0 0 1 2.982-1.245z" style="-inkscape-stroke:none" transform="translate(-25.339 -16.569) scale(.5717)"/></g></svg>
</span>
 Back to GPU Programming </a>
        <div id="post-head">
            <h1>The Anatomy of a WebGPU Program</h1>
            <h4>For those who want to learn graphics programming but don&rsquo;t know where to start</h4>

            <div class="date">

                <p>August 2, 2023</p>
                <div class="tag-list">
                    

                    
                    <span class="tag">gpu</span>
                    
                    <span class="tag">rust</span>
                    
                </div>
            </div>
        </div>

        <div class="content">
            <p>You might be like me and want to learn high performance graphics programming,
but are not interested in using the often intimidating C/C++ APIs for OpenGL.
Luckily, there&rsquo;s a new kid on the block. WebGPU is the next generation API for
accessing the GPU through the browser. Unlike WebGL, it is accessible outside
of the browser and supports general purpose compute! You also gain a modern
graphics API with cross platform support. For the vast majority of people, WebGPU
is more than adequate. <a href="https://github.com/veloren/veloren">Entire games</a> have been built using it. However, If you
have come to extract every last drop of performance, this might not be the API
for you.</p>
<p>I am new to the game, but I would like to share my high level understanding of
WebGPU for those of you without any prior GPU programming experience. My goal is to convey
the flow of the program instead of diving into the details of configuring WebGPU
to work. If you are looking for step by step directions on building your first
graphics program, I can highly recommend this <a href="https://sotrh.github.io/learn-wgpu/">tutorial</a> for Rust and this
<a href="https://webgpufundamentals.org/">one</a> for Javascript but also is a great reference.</p>
<p>My snippets will be based on a program I wrote using <code>wgpu</code> (the Rust WebGPU implementation)
that displays a spinning pentagon.</p>
<figure  ><div class="image-container">
            
            
            
            




    
    <img
    src="/journey/graphics/log1/pentagon.gif"
     class="batch-load" 
    
     alt="My spinning pentagon program" 
    loading="lazy" 

    style="
         width: 450px;  
         height: 450px; 
        
    "
    />



        </div>
        <figcaption>
            My spinning pentagon program
        </figcaption>
    
</figure>

<h1 id="what-is-the-computer-doing-behind-the-scenes">What is the computer doing behind the scenes?</h1>
<p>At its core, GPUs are massively parallel, number-crunching machines. This is an
ideal tool for computer graphics. Any surface we see can be approximated as a
collection of triangles glued together. And as the number of triangles goes up,
so does the apparent quality of our computer generated object. Computing lots
of triangles becomes an unwieldy problem very fast.</p>
<figure  ><div class="image-container">
            
            
            
            




    
    <img
    src="/journey/graphics/log1/polygon_triangles.svg"
     class="batch-load" 
    
     alt="The shape appears to become circular, but it still is an n-sided shape to the computer." 
    loading="lazy" 

    style="
         
        
        
    "
    />



        </div>
        <figcaption>
            The shape appears to become circular, but it still is an n-sided shape to the computer.
        </figcaption>
    
</figure>

<p>You might ask why this job can&rsquo;t be handled by the CPU. It can, but it&rsquo;s like
using a pocketknife for a very specialized machine screw. The CPU is meant to be
general purpose and has a much wider variety of instructions to support. On the
other hand, a GPU is like a hyper-specialized power drill whose sole purpose is
to crank out a few kinds of screws insanely fast. You can use a mental shortcut to determine
if your problem is suitable for a GPU. A CPU may have a few large problems to
solve while a GPU may have thousands of tiny problems to solve.</p>
<p>The relationship between programming languages and the GPU wasn&rsquo;t all that clear
to me before starting. I thought that programming a GPU was the same
as compiling and running C++ code for another architecture. But in fact, the GPU
does not execute a C/C++/Rust/etc binary. The role of the programming language,
and by extension the CPU, is to configure and supply commands to be processed
by the GPU, sort of like requests and responses in web development.</p>
<p>Afterwards, your GPU executes a short program on the data sent in
using what is known as a <strong>shader language</strong>. This is like a stripped down
programming language that contains only commands that are understood by the GPU,
mostly mathematical operations like addition, subtraction, multiplication, etc.</p>
<p>This fact is key to understanding what <code>WebGPU</code> does. It is so important that I
will repeat it again.</p>
<blockquote>
<p>The role of the programming language is to configure and supply the data to be processed by the GPU. Afterwards, your GPU executes instructions on the data using a shader language.</p>
</blockquote>
<h1 id="what-does-a-shader-do">What does a shader do?</h1>
<p>The shader language used by WebGPU is known as the WebGPU Shader Language (WGSL)
as it is creatively named. It has a likeness to Rust in regards to syntax, but
it has some quirks. See <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl.html">this</a>
resource for a proper introduction.</p>
<p>To answer the question, it depends. WebGPU has three different kinds of shaders
that can be used. A vertex shader, fragment shader, and compute shader. The
first two are used for graphics specifically while the third is used for general
compute.</p>
<p>The purpose of the <strong>vertex shader</strong> can be easily understood as function that
transforms (if necessary) the vertices sent by the CPU. It is a one-to-one
mapping of vertices that is deterministic. For example, you might want to make a vertex shader that rotates
all the vertices by 90 degrees. This shader function has an input of
a single vertex, but the GPU scales this operation to thousands of vertices at
a time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// Pseudocode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">vertex_shader</span><span class="p">(</span><span class="k">in</span>: <span class="nc">Vertex</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Vertex</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>The <strong>fragment shader</strong> is quite interesting. It takes the processed vertices
and computes what color that should be displayed for that vertex. This could be
used for a ray tracer which determines what color to display based on the amount
of light that hits it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// Psuedocode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">fragment_shader</span><span class="p">(</span><span class="k">in</span>: <span class="nc">Vertex</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">RGBA</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>If you were to run a fragment shader on three vertices, each being assigned red,
green, and blue, you would expect the pixel for each vertex to be a certain color.</p>
<figure  ><div class="image-container">
            
            
            
            




    
    <img
    src="/journey/graphics/log1/expected_shader.svg"
     class="batch-load" 
    
     alt="Expected RGB triangle" 
    loading="lazy" 

    style="
         
         height: 200px; 
        
    "
    />



        </div>
        <figcaption>
            Expected RGB triangle
        </figcaption>
    
</figure>

<p>However, what you get is this:</p>
<figure  ><div class="image-container">
            
            
            
            




    
        
    
    <img
    src="/journey/graphics/log1/webgpu-triangle_hu3421092764743411439.webp"
     class="batch-load" 
    
     alt="WebGPU output" 
    loading="lazy" 

    style="
         width: 300px;  
         height: 300px; 
        
    "
    />



        </div>
        <figcaption>
            WebGPU output
        </figcaption>
    
</figure>

<p>Somehow from specifying only 3 colors we ended up with a triangle that contains
the whole rainbow! This is a result of <strong>interpolation</strong> and <strong>rasterization</strong>.</p>
<p>A rasterizer essentially takes in the outline of a shape and can color in the
empty space. Like a person doing a coloring book.</p>
<p>Interpolation is the cousin to extrapolation. Extrapolation is making a prediction
about a new value outside of your dataset, assuming that a trend holds. Meanwhile
interpolation makes a prediction about a value that is contained within your dataset.</p>
<p>As the computer we don&rsquo;t know what color the inside of the triangle should be,
but maybe we make the assumption that the pixels inside the triangle should be
a mix of the three colors depending on how close a point is to each corner.</p>
<p>You can see that as you are closer to the blue color, the more blue
it is. So for any associated parameters of the <code>Vertex</code> passed in, like color, the GPU
will interpolate it based on the position to fill in the blanks. You can find a
more detailed explanation of the algorithm used by OpenGL in <a href="https://stackoverflow.com/a/24460895/10521417">this StackOverflow
post</a>.</p>
<p>With some significant oversimplification, the whole process of graphics programming
(for the scope of this mini-project) boils down to this:</p>
<ol>
<li>(CPU)  Provide a window/canvas for the GPU to draw to.</li>
<li>(CPU)  Configure the GPU for your workload and shaders.</li>
<li>(CPU)  Handle any window events like clicks, re-draws, etc.</li>
<li>(CPU)  Modify and/or send vertex data to the vertex shader.</li>
<li>(GPU)  Run the vertex shader.</li>
<li>(GPU)  Run the fragment shader.</li>
<li>(CPU)  Repeat steps 3-6.</li>
</ol>
<h1 id="cutting-through-the-webgpu-jargon">Cutting through the WebGPU jargon</h1>
<p>So far we haven&rsquo;t talked about anything specific to WebGPU, but now I would like
to give some illumination as to what some common objects represent. Here is what
my program state looks like. This struct contains the most useful objects to
keep track of while running the program.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// bare minimum program state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">window</span>: <span class="nc">winit</span>::<span class="n">window</span>::<span class="n">Window</span><span class="p">,,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">size</span>: <span class="nc">winit</span>::<span class="n">dpi</span>::<span class="n">PhysicalSize</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">surface</span>: <span class="nc">wgpu</span>::<span class="n">Surface</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">config</span>: <span class="nc">wgpu</span>::<span class="n">SurfaceConfiguration</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">device</span>: <span class="nc">wgpu</span>::<span class="n">Device</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">queue</span>: <span class="nc">wgpu</span>::<span class="n">Queue</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Additional state for the the pentagon 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">vertex_buffer</span>: <span class="nc">wgpu</span>::<span class="n">Buffer</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">index_buffer</span>: <span class="nc">wgpu</span>::<span class="n">Buffer</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">animation</span>: <span class="nc">AnimationState</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">render_time</span>: <span class="kt">u128</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">color</span>: <span class="nc">wgpu</span>::<span class="n">Color</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">mode</span>: <span class="nc">PipelineMode</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">pipelines</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">PipelineMode</span><span class="p">,</span><span class="w"> </span><span class="n">wgpu</span>::<span class="n">RenderPipeline</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h1 id="the-window-and-surface">The Window and Surface</h1>
<p>The Window and Surface go hand in hand. The surface represents the place that WebGPU
writes pixel data, which is most likely a window but could be a web canvas.
<code>Surface</code> is specific to the <code>wgpu</code> implementation. <code>SurfaceConfiguration</code>
contains information about the window&rsquo;s size and a few other parameters.</p>
<p>The window also gives us access to events like mouse clicks, key presses, and
more. A particularly handy one is the <code>Event::RedrawRequested</code>.
You can time how long it takes to render a frame in order to animate the pentagon.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">match</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Event</span>::<span class="n">WindowEvent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">window_id</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">same_window</span><span class="p">(</span><span class="n">window_id</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Handle events
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Event</span>::<span class="n">RedrawRequested</span><span class="p">(</span><span class="n">window_id</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">same_window</span><span class="p">(</span><span class="n">window_id</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// v------------- this is very useful!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SystemTime</span>::<span class="n">now</span><span class="p">().</span><span class="n">duration_since</span><span class="p">(</span><span class="no">UNIX_EPOCH</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_nanos</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">render</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">wgpu</span>::<span class="n">SurfaceError</span>::<span class="n">Lost</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">size</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">wgpu</span>::<span class="n">SurfaceError</span>::<span class="n">OutOfMemory</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">control_flow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ControlFlow</span>::<span class="n">Exit</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// All other errors (Outdated, Timeout) should be resolved by the next frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SystemTime</span>::<span class="n">now</span><span class="p">().</span><span class="n">duration_since</span><span class="p">(</span><span class="no">UNIX_EPOCH</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_nanos</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">state</span><span class="p">.</span><span class="n">render_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         
</span></span></span></code></pre></div><h1 id="the-device-and-adapter">The Device and Adapter</h1>
<p>The adapter is essentially the wrapper around the graphics API for your system.
WebGPU sends native GPU calls on your behalf while you use the standardized
interface. For every GPU you intend to use, you need an adapter since it may
have a different API.</p>
<p>Confusingly, the <code>Device</code> object is not referring to your entire GPU.
WebGPU was intended for use in browsers with multiple tabs potentially accessing
the same resources. A <code>Device</code> provides compartmentalized access to your GPU.</p>
<h1 id="pipelines-and-buffers">Pipelines and Buffers</h1>
<p>Pipelines are the entrypoint of shader programs and are executed at every render
pass. You can have multiple pipelines to render different effects and composite
all of them together on one image. For example, you could have one shader pipeline
render a triangle mesh and overlay that ontop of the results of your
standard rendering pipeline.</p>
<p>When we discussed shaders earlier, I mentioned that the shader can receive
vertex data. A vertex can be any struct you define, not limited to <code>x, y, z</code>
coordinates. You may choose to also include color information.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// bytemuck::Pod means that the struct is &#34;Plain Old Data&#34; and 
</span></span></span><span class="line"><span class="cl"><span class="sd">/// is interpretable as &amp;[u8]. 
</span></span></span><span class="line"><span class="cl"><span class="sd">/// bytemuck::Zeroable means that struct attributes can be set
</span></span></span><span class="line"><span class="cl"><span class="sd">/// to 0 (references cannot be zeroed)
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="cp">#[repr(C)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">position</span>: <span class="p">[</span><span class="kt">f32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">color</span>: <span class="p">[</span><span class="kt">f32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>However, the GPU needs to know how the <code>Buffer</code> is layed out in memory. The
number of vertices in a 1,000 byte buffer depends on how much memory a single
vertex consumes. The <code>array_stride</code> is how large a single vertex is. For the
fields of this struct to be correctly interpreted, the <code>offset</code> is used to
indicate how far from the start of this vertex is the start of the next field.
In this example, position has no offset. Meanwhile color is offset by however
large position is.</p>
<p>For the more visual minded, here is a graphic.
<figure  ><div class="image-container">
            
            
            
            




    
    <img
    src="/journey/graphics/log1/vertex_memory.svg"
     class="batch-load" 
    
     alt="Memory representation of Vertex" 
    loading="lazy" 

    style="
         
        
        
    "
    />



        </div>
        <figcaption>
            Memory representation of Vertex
        </figcaption>
    
</figure>
</p>
<p>There is a macro that can automatically generate the memory layout of <code>Vertex</code>,
but for the sake of completeness here is how to describe the layout.</p>
<p>(I apologize for how atrocious the syntax highlighting is. Chroma sucks.)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// Creates a description of the memory layout of the Vertex struct
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">description</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">wgpu</span>::<span class="n">VertexBufferLayout</span><span class="o">&lt;</span><span class="nb">&#39;static</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">wgpu</span>::<span class="n">VertexBufferLayout</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Width of a single vertex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">array_stride</span>: <span class="nc">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">wgpu</span>::<span class="n">BufferAddress</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">step_mode</span>: <span class="nc">wgpu</span>::<span class="n">VertexStepMode</span>::<span class="n">Vertex</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">attributes</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">wgpu</span>::<span class="n">VertexAttribute</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Represents position
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="n">offset</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// offset from the start of the vertex struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="n">shader_location</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// used by wgsl to populate its struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="n">format</span>: <span class="nc">wgpu</span>::<span class="n">VertexFormat</span>::<span class="n">Float32x3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">wgpu</span>::<span class="n">VertexAttribute</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Represents color
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="n">offset</span>: <span class="nc">std</span>::<span class="n">mem</span>::<span class="n">sizeof</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">wgpu</span>::<span class="n">BufferAddress</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">shader_location</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">format</span>: <span class="nc">wgpu</span>::<span class="n">VertexFormat</span>::<span class="n">Float32x3</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>You may notice the <code>shader_location</code> field. This is important for our shader
code. In one of my shaders I have a struct that looks almost exactly like the
Vertex struct. The <code>@location(0)</code> attribute tells WebGPU to map the position
<code>VertexAttribute</code> to this field of the WGSL struct. It is unfortunately a little
redundant, but it is the way of the world.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// Vertex struct passed in by rust code through buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">VertexInput</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">position</span>: <span class="nc">vec3</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">@</span><span class="n">location</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">color</span>: <span class="nc">vec3</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Vertex shader code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">@</span><span class="n">vertex</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">vs_main</span><span class="p">(</span><span class="n">model</span>: <span class="nc">VertexInput</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">VertexOutput</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="n">out</span>: <span class="nc">VertexOutput</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">.</span><span class="n">color</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="n">clip_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h1 id="the-queue">The Queue</h1>
<p>This is how we can send commands to the GPU for processing.</p>
<p>One command that is really useful is <code>queue::write_buffer()</code>. This can update any buffer object
with new data. For example, when I animate my pentagon I apply a linear
transformation to rotate the vertices. But those updated vertices do not
get sent over to the GPU <em>until</em> I queue them up.</p>
<p>I originally thought that the GPU would automatically update the vertex buffer
if I modified the reference to which <code>Buffer</code> was initialized with. I think this is a nice example of how the borrow
checker actually works <em>for</em> the programmer instead of against them.</p>
<p>It would be impossible for me to mutate my array of vertices if
the buffer retained a read only reference. Therefore, <code>Buffer</code> must retain a copy
of the memory and not a reference.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">animation</span><span class="p">.</span><span class="n">rotating_pentagon</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">render_time</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">write_buffer</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">vertex_buffer</span><span class="p">,</span><span class="w"> </span><span class="c1">// the buffer object to update 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="mi">0</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">wgpu</span>::<span class="n">BufferAddress</span><span class="p">,</span><span class="w"> </span><span class="c1">// offset to overwrite a specific section of memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">bytemuck</span>::<span class="n">cast_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">animation</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span><span class="w"> </span><span class="c1">// the new data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h1 id="concluding-thoughts">Concluding thoughts</h1>
<p>This was not an exhaustive guide to WebGPU by any means, but hopefully I have
imparted some appreciation and motivation on how to use WebGPU. As someone
who has only recently started to learn about graphics programming, I have found
the combination of WebGPU and Rust to be an intuitive pair of tools to use.
I&rsquo;ll be sure to share any of my other learnings as I build more complex
graphical applications!</p>
<p>If you notice any errors or have any other feedback, please contact me <a href="mailto:kalin.kochnev@gmail.com">here</a>!</p>

        </div>
        <div class="next-prev">
             

            <div class="section-nav">
                
            </div>

            <div class="section-nav">
                
            </div>
        </div>
    </div>
</div>

        </div>
        
<footer>
    <div id="love">
        <p>
        Made with love
        </p>

        <span 
     class="star-icon"  
>
    
<svg width="100%" height="100%" version="1.1" viewBox="0 0 23.168 20.232" xmlns="http://www.w3.org/2000/svg">
 <g transform="translate(-101.93 -34.643)">
  <path d="m108.77 37.95c-2.7926-0.0069-3.6384 2.4755-3.5284 4.7815 1.4308 6.5185 8.2134 9.0305 8.2134 9.0305s6.6452-2.3888 8.214-9.0305c0.53071-2.2468-0.88642-4.781-3.679-4.7741-3.5787 0.0088-4.5347 3.8324-4.5347 3.8324s-1.1067-3.831-4.6853-3.8398z" fill="#ff0003" stroke="#000" stroke-linecap="round" stroke-miterlimit="0" stroke-width="6.6146" style="paint-order:markers stroke fill"/>
 </g>
</svg>

</span>
 
    </div>
    
</footer>

    </body>
</html>
