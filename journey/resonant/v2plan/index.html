<!DOCTYPE html>
<html>


<link rel="stylesheet" href="/scss/main.css" />


<script src="/js/batch-load.js"></script>
 

<meta name="viewport" content="width=device-width, initial-scale=1">



<head>
 <title>Kalin Kochnev</title>
 <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
</head>
<body>
        
        <div id="content">


<link rel="stylesheet" href="/scss/main.css" />


<script src="/js/batch-load.js"></script>
 

<meta name="viewport" content="width=device-width, initial-scale=1">



<head>
 <title>Kalin Kochnev</title>
 <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
</head>

<header>  
  <nav class="navbar" role="navigation">  
    <div id="face-icon">
      





    
    <img 
        src="/images/face_hu03cb41ba356b0fd884adcc4944d0157c_969556_60x0_resize_q90_h2_box_3.webp" 
         
        

        alt=""
  
    />

      <div id="name"> 
        
        <a href="/">kalin kochnev</a>
        
      </div>  
    </div>
    
    <div id="right">  
      <a href="/journey">journeys</a>  
      <a href="/blog">blog</a>
    </div>  
  </nav>  
</header>  

<div class="single-container">
  <div class="post-page">
    <div id="post-head">
      <h1>Resonant V2 Plans!</h1>
      <h4>There&rsquo;s plenty of unfinished business</h4>

      <div class="date">

        <p>March 10, 2023</p>
        <div class="tag-list">
          

          
          <span class="tag">signal-processing</span>
          
        </div>
      </div>
    </div>

    <div class="content">
      <h1 id="personal-significance">Personal significance</h1>
<p><a href="https://kalinkochnev.com/journey/resonant/" title="Resonant">Resonant</a> is a project that is very near and dear to my heart. It was my first significant hardware project and it was also a pivotal moment in my <a href="https://kalinkochnev.com/blog/worryaboutnow/">personal development</a> as well. During high school I felt very stuck because I had learned so much about coding, but could not get a single project off the ground. Resonant was what validated, at least to myself, that I can create something cool.</p>
<p>Now I&rsquo;m coming back to work on it to explore more about audio localization and signal processing. There was a lot left to learn and I&rsquo;d like to make a second attempt now that I have the mathematical background to dive deeper.</p>
<h1 id="picking-a-language-rust-vs-alternatives">Picking a language: Rust vs. alternatives</h1>
<p>I worked a lot on the programming aspect of the project, and normally I pride myself on my code style, but our codebase <em>barely</em> worked. Looking back, it was a threading nightmare I was not equipped to handle. I wrote it in Python which I really disliked doing. If I&rsquo;m assigning type annotation to variables in Python, I might as well use a language that will verify the code before running. Additionally we used Numpy as a hack to speed up array manipulation and ideally would work with actual arrays.</p>
<p>Nowadays I am a big fan of statically typed languages, but the tooling feels much more archaic. That is why I really like Rust. It is more modern and has great utilities for programming (package manager, built in unit testing, and linting) and I really like the emphasis on error handling. I felt a lot more confident that if my code compiled, it would function as expected. I can hardly think of any runtime errors I experienced while using Rust.</p>
<p>Meanwhile in C/C++ there&rsquo;s all this friction associated with coding. I want to worry about programming and not setting up my Makefile. And most of the time, 90% of the errors occur during runtime which is a pretty big downside.</p>
<p>However, with all the niceties of Rust, there are some significant problems I discovered. I convinced my team for the <a href="https://kalinkochnev.com/journey/nasabigidea/">NASA BIG Idea Challenge</a> to use Rust and it became really apparent the disadvantage that put us in. When it comes to robotics, Rust has borderline no tooling, while there are probably thousands of packages for C++ and ROS. Even though the developer experience for Rust is much nicer, there is a massive learning curve for actually coding in the language. I read in another article that it took about 4-6 months before the person was coding productively. I am inclined to agree.</p>
<p>The rules of Rust are pretty esoteric compared to all other languages. That non-transferability in skill is something that concerns me as a student who is graduating college in a few years. I really enjoy coding in Rust, but C++ dominates industry and scientific applications.</p>
<p>As of today, Rust is useful in two scenarios.</p>
<ol>
<li>You are writing a standalone application with minimal dependencies</li>
<li>You have an extreme need for thread safety</li>
</ol>
<p>Rust is not useful if</p>
<ol>
<li>You need to prototype</li>
</ol>
<p>I would prefer to re-write Resonant in Rust, but I think I could benefit from experience using C++, even if it means I will kick myself later for doing so. I really wish there was a good alternative to C++ that wasn&rsquo;t so painful to work with.  <a href="https://github.com/carbon-language/carbon-lang">Carbon</a> seems really promising, but if I&rsquo;m using another esoteric language, I might as well just use Rust.</p>
<h1 id="audio-localization-methods">Audio localization methods</h1>
<p>One of the major downsides of Resonant V1 was that it could only localize a single source in 2D space. Anything of greater complexity was outside of our reach at the time.</p>
<p>I had researched different sound localization methods and tangential topics, but this one paper by <a href="">François Grondin and François Michaud </a> summarizes the sound localization problem and its methods nicely (as well as providing a new method that is substantially better than existing ones). This is where I will be getting most of this information from.</p>
<p>Understanding the sound environment can be broken up into two problems:</p>
<ol>
<li><strong>Sound Source Localization (SSL):</strong> estimating what position in space a sound is coming from, accomplished by direction of arrival estimation (DoA)</li>
<li><strong>Sound Source Tracking (SST)</strong>: evaluating potential sounds from sound localization and pruning irrelevant ones</li>
</ol>
<h2 id="sound-source-localization-ssl">Sound Source Localization (SSL)</h2>
<p>There is a lot of research for different sound localization algorithms, each with its own drawbacks. My high level understanding is that there are two classes of algorithms.</p>
<p>One class searches for sources by sampling discrete points in space and plugging them into a delay-and-sum beamformer (just think of it as a function that scores higher if there is a source and lower if not). This is known as the Steered-Response Power Phase Transform (<a href="https://en.wikipedia.org/wiki/Steered-Response_Power_Phase_Transform">SRP-PHAT</a>) method.</p>
<p>I&rsquo;m not so confident about this class, but it appears to use linear algebra to estimate the source locations that minimize an error function. I have seen a paper on a <a href="https://ieeexplore.ieee.org/document/1165089">Least-Squares</a> solution that accomplishes this, but also the popular ones are variations of family <a href="https://en.wikipedia.org/w/index.php?title=MUSIC_(algorithm)">MUSIC</a> and <a href="https://en.wikipedia.org/wiki/SAMV_(algorithm)">SAMV</a> family.</p>
<p>These are both interesting in their own right and I plan to try implementing at least one algorithm of each type. All of these algorithms are capable of multi-source localization in 3D space.</p>
<h2 id="sound-source-tracking-sst">Sound Source Tracking (SST)</h2>
<p>I haven&rsquo;t investigated sound source tracking at all until today, so I can&rsquo;t comment on the effectiveness or the methods too much.</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Viterbi_algorithm">Viterbi search</a></strong> is a dynamic programming algorithm that determines the most likely sequence of states that resulted in observed outcomes. This is related to the Hidden Markov Model model which basically indicates the likelihood of transitioning from one state of a system to another with hidden variables.</p>
<p><strong><a href="https://jblevins.org/notes/smc-intro">Sequential Monte Carlo</a></strong> which updates a posterior probability distribution. A posterior probability distribution is a model that indicates your knowledge/belief of the state of the system based on some prior information. It is often useful to update your assumptions (your prior) given some new evidence/information.</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Kalman_filter">Kalman filtering</a></strong> which has a similar purpose of estimating the state of a system with new information. It appears to have the ability to combine multiple forms of feedback to improve the estimate of a system, as a form of <a href="https://en.wikipedia.org/wiki/Sensor_fusion">sensor fusion</a>.</p>
<p>Another algorithm is the <strong><a href="https://en.wikipedia.org/wiki/Joint_Probabilistic_Data_Association_Filter">joint probabilistic data-association filter</a></strong>, but I couldn&rsquo;t find much information.</p>
<h1 id="the-plan">The Plan</h1>
<p>I&rsquo;m working with <a href="https://www.rohanmenon.com/">Rohan Menon</a> once more on this project. We will be following the paper by <a href="">François Grondin and François Michaud </a> as a first attempt of experimenting with this problem.</p>
<h2 id="algorithm">Algorithm</h2>
<p>Their solution is a variation of SRP-PHAT and Kalman Filtering. Their version applies a refined search procedure for SRP-PHAT which is generally a more performant than the non-SRP ones. Additionally they use a Kalman filter in Cartesian coordinates instead of spherical. They say there are innacuracies with the Kalman filter as the azimuth increases.</p>
<p>Afterwards we may experiment with some of the less optimal methods since it is a great learning exercise for math and signal processing.</p>
<h2 id="software-and-hardware">Software and hardware</h2>
<p>I have decided that I&rsquo;m going to code the algorithms in C++ just so I can leave my Rust comfort zone and gain experience with modern systems programming.</p>
<p>Additionally, compared to V1, we will be doing much more work in simulation. In fact, it&rsquo;s possible that the entirety of the project may be done in simulation (<a href="https://github.com/LCAV/pyroomacoustics">pyroomaccoustics</a> looks like a great package!). Working with hardware is a pain in the neck, especially while prototyping algorithms and getting accurate test data. We will see what happens as we progress. Having hardware is cool to show off.</p>
<p>Once/while the localization and tracking algorithms are being established, we might also investigate audio classification since that was a signficiant aspect of our project.</p>
<h1 id="goals-and-conclusion">Goals and conclusion</h1>
<p>I would like to apply the math and programming I know in a way that is moderately useful and teaches me things along the way. I&rsquo;m trying to figure this stuff out as I go. This is my first time learning about all of these things, so I hope you find my journey interesting.</p>
<p>Books I&rsquo;m reading currently related to the project:</p>
<ul>
<li>A Tour of C++ by Bjarne Stroustrup (inventor of C++)</li>
<li>Understanding Digital Signal Processing by Richard G. Lyons</li>
</ul>

    </div>
  </div>
</div><noscript>
    <style>
        .image-container {
            opacity: 1 !important;
        }
    </style>
</noscript>
        </div><noscript>
    <style>
        .image-container {
            opacity: 1 !important;
        }
    </style>
</noscript></body>
</html>
